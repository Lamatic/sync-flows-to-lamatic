name: "Sync Flows to lamatic"
description: "Detects changed flow files, updates them via API, and optionally deploys them."
author: "Lamatic.ai"
branding:
  icon: 'zap'  
  color: 'red'
  
inputs:
  lamatic-endpoint:
    description: "Lamatic Project API endpoint"
    required: true
  api-key:
    description: "Lamatic Projects API key"
    required: true
  project-id:
    description: "Lamatic Project ID"
    required: true
  auto-deploy:
    description: "Auto deploy project after flows are synced"
    required: true
    
runs:
  using: "composite"
  steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Get list of changed files
      id: changed-files
      uses: tj-actions/changed-files@v34

    - name: Extract flowSlugs from changed files and update
      id: update-flows
      shell: bash
      run: |
        echo "Changed files:"
        echo "${{ steps.changed-files.outputs.all_changed_files }}"
        changed_files="${{ steps.changed-files.outputs.all_changed_files }}"
        declare -A flowSlugs=()
        failed=0
        for file in $changed_files; do
          if [[ $file =~ ^lamatic/flows/([^/]+).ts$ ]]; then
            flowSlug="${BASH_REMATCH[1]}"
            flowSlugs["$flowSlug"]=1
            if [[ ! -f "$file" ]]; then
              echo "Error: File $file does not exist"
              failed=1
              continue
            fi
            contents=$(cat "$file" | jq -Rs .)
            if [[ $? -ne 0 ]] || [[ -z "$contents" ]]; then
              echo "Error: Failed to read or process file $file"
              failed=1
              continue
            fi
            # Use jq to properly construct the JSON payload
            # Note: $contents is already a JSON string from jq -Rs ., so we parse it back
            data=$(jq -n \
              --arg query "query UpdateFlow(\$flowSlug: String!, \$rawContent: String) { updateFlow(flowSlug: \$flowSlug, rawContent: \$rawContent) { status result } }" \
              --arg flowSlug "$flowSlug" \
              --argjson rawContent "$contents" \
              '{query: $query, variables: {flowSlug: $flowSlug, rawContent: $rawContent}}')
            echo "Updating flow: $flowSlug"
            response_body=$(mktemp)
            http_code=$(curl -s -w "%{http_code}" -o "$response_body" -X POST "${{ inputs.lamatic-endpoint }}" \
              -H "Authorization: Bearer ${{ inputs.api-key }}" \
              -H "x-project-id: ${{ inputs.project-id }}" \
              -H "Content-Type: application/json" \
              --data "$data" \
              --max-time 30 \
              --retry 2)
            curl_exit=$?
            if [[ $curl_exit -ne 0 ]]; then
              echo "Error: curl failed with exit code $curl_exit"
              echo "Response body (if any):"
              cat "$response_body" 2>/dev/null || echo "(no response body)"
              failed=1
              rm -f "$response_body"
              continue
            fi
            echo "HTTP Status: $http_code"
            if [[ "$http_code" -ne 200 ]]; then
              echo "Failed request for $flowSlug: HTTP $http_code"
              echo "Response body:"
              cat "$response_body"
              failed=1
            else
              echo "Successfully updated flow: $flowSlug"
            fi
            rm -f "$response_body"
          fi
        done

        if [[ $failed -eq 1 ]]; then
          echo "One or more update requests failed."
          exit 1
        fi
        # Output JSON array for deployment step
        flowSlugs_json=$(printf '%s\n' "${!flowSlugs[@]}" | jq -R . | jq -s .)
        echo "flowSlugs_json<<EOF" >> "$GITHUB_OUTPUT"
        echo "$flowSlugs_json" >> "$GITHUB_OUTPUT"
        echo "EOF" >> "$GITHUB_OUTPUT"
        echo $flowSlugs_json

    - name: Check for auto deployment
      id: check-for-auto-deployment
      shell: bash
      run: echo "auto_deploy=${{ inputs.auto-deploy }}" >> "$GITHUB_OUTPUT"

    - name: Deploy updated flows
      if: steps.update-flows.outputs.flowSlugs_json != '' && steps.check-for-auto-deployment.outputs.auto_deploy == 'true'
      shell: bash
      run: |
        echo "Deploying flows"
        flowSlugs_json='${{ steps.update-flows.outputs.flowSlugs_json }}'
        # Use jq to properly construct the JSON payload
        data=$(jq -n \
          --arg query "query DeployFlows(\$flowSlugs: [String!]!) { deployFlows(flowSlugs: \$flowSlugs) { status result } }" \
          --argjson flowSlugs "$flowSlugs_json" \
          '{query: $query, variables: {flowSlugs: $flowSlugs}}')
        response_body=$(mktemp)
        http_code=$(curl -s -w "%{http_code}" -o "$response_body" -X POST "${{ inputs.lamatic-endpoint }}" \
          -H "Authorization: Bearer ${{ inputs.api-key }}" \
          -H "x-project-id: ${{ inputs.project-id }}" \
          -H "Content-Type: application/json" \
          --data "$data" \
          --max-time 30 \
          --retry 2)
        curl_exit=$?
        if [[ $curl_exit -ne 0 ]]; then
          echo "Error: curl failed with exit code $curl_exit"
          echo "Response body (if any):"
          cat "$response_body" 2>/dev/null || echo "(no response body)"
          rm -f "$response_body"
          exit 1
        fi
        echo "HTTP Status: $http_code"
        if [[ "$http_code" -ne 200 ]]; then
          echo "Failed request for deployFlows: HTTP $http_code"
          echo "Response body:"
          cat "$response_body"
          rm -f "$response_body"
          exit 1
        else
          echo "Successfully deployed flows"
        fi
        rm -f "$response_body"
